<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enigma Machine Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Special+Elite&display=swap"
        rel="stylesheet">
    <style>
        body {
            font-family: 'Roboto Mono', monospace;
            background-color: #1a1a1a;
            color: #f0f0f0;
        }

        .font-title {
            font-family: 'Special Elite', cursive;
        }

        .enigma-key {
            transition: all 0.1s ease;
            box-shadow: 0 3px 0 #4a4a4a;
        }

        .enigma-key:active {
            transform: translateY(2px);
            box-shadow: 0 1px 0 #4a4a4a;
        }

        .lamp {
            transition: all 0.1s ease-in-out;
        }

        .lamp.lit {
            background-color: #fef08a;
            /* yellow-200 */
            color: #1a1a1a;
            box-shadow: 0 0 12px 4px #fef08a;
            transform: scale(1.1);
        }

        .rotor-display {
            background-color: #333;
            border: 2px solid #555;
        }

        .plug-socket {
            transition: background-color 0.2s;
        }

        .plug-socket.selected {
            background-color: #eab308;
            /* yellow-500 */
            color: #1a1a1a;
        }

        textarea,
        #output-display {
            background-color: #2a2a2a;
            border: 1px solid #4a4a4a;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #2a2a2a;
        }

        ::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #777;
        }
    </style>
</head>

<body class="p-2 md:p-4">

    <header class="text-center mb-4">
        <h1 class="text-3xl md:text-4xl font-title text-yellow-400">DESEC ENIGMA M3 Simulator</h1>
        <p class="text-gray-400 text-sm">German Enigma Machine Simulator - version 1.19</p>
    </header>

    <div class="flex flex-col md:flex-row gap-4 max-w-7xl mx-auto">
        <!-- Left Column: Notepad and Output -->
        <div class="w-full md:w-1/3 flex flex-col gap-2">
            <div>
                <h2 class="text-xl font-title text-yellow-400 mb-2">Input</h2>
                <textarea id="notepad"
                    class="w-full h-60 p-3 rounded-lg focus:outline-none focus:ring-2 focus:ring-yellow-500 resize-y"
                    placeholder="Type your plaintext here..."></textarea>
            </div>

            <!-- Transfer Button -->
            <div class="text-center">
                <button id="transfer-btn" title="Move text to decrypt"
                    class="p-2 bg-gray-700 hover:bg-yellow-600 rounded-full text-white transition-colors">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
                        class="bi bi-arrow-up" viewBox="0 0 16 16">
                        <path fill-rule="evenodd"
                            d="M8 15a.5.5 0 0 0 .5-.5V2.707l3.146 3.147a.5.5 0 0 0 .708-.708l-4-4a.5.5 0 0 0-.708 0l-4 4a.5.5 0 1 0 .708.708L7.5 2.707V14.5a.5.5 0 0 0 .5.5z" />
                    </svg>
                </button>
            </div>

            <div>
                <h2 class="text-xl font-title text-yellow-400 mb-2">Output</h2>
                <div id="output-display"
                    class="w-full h-40 p-3 rounded-lg font-mono text-base break-all overflow-y-auto"></div>
                <div class="flex justify-end gap-2 mt-3">
                    <button id="help-btn"
                        class="px-3 py-1.5 bg-gray-600 hover:bg-gray-700 rounded-lg text-white text-sm font-bold transition-colors">HELP</button>
                    <button id="clear-output"
                        class="px-3 py-1.5 bg-gray-600 hover:bg-gray-700 rounded-lg text-white text-sm font-bold transition-colors">Reset
                        Enigma</button>
                </div>
            </div>
            <div>
                <h2 class="text-xl font-title text-yellow-400 mb-2">Load Decryption Setup</h2>
                <div class="relative">
                    <textarea id="import-config"
                        class="w-full h-24 p-3 pb-6 rounded-lg focus:outline-none focus:ring-2 focus:ring-yellow-500 resize-y text-xs"
                        placeholder="Paste the setup here to load it automatically..."></textarea>
                    <div class="absolute left-2 right-2 bottom-2 h-1 bg-gray-700/80 rounded-full overflow-hidden">
                        <div id="import-progress" class="h-full bg-yellow-500 w-0 transition-all duration-150">
                        </div>
                    </div>
                </div>
                <div class="text-center mt-2">
                    <button id="load-import-config"
                        class="px-3 py-1.5 bg-yellow-600 hover:bg-yellow-700 rounded-lg text-white text-sm font-bold transition-colors">Load
                        this setup</button>
                </div>
            </div>
        </div>

        <!-- Right Column: Enigma Machine and Plugboard -->
        <div class="w-full md:w-2/3 flex flex-col gap-4">
            <!-- Máquina Enigma -->
            <div class="bg-[#111] p-4 rounded-xl shadow-2xl border border-gray-700">
                <!-- Rotor Settings -->
                <div class="mb-4">
                    <h3 class="text-lg font-title text-yellow-400 mb-3 text-center">Rotor Settings</h3>
                    <div id="rotors-settings" class="flex justify-center items-center gap-2 md:gap-4">
                        <!-- Os rotores serão inseridos aqui pelo JavaScript -->
                    </div>
                    <div class="text-center mt-3">
                        <button id="reset-rotors"
                            class="px-3 py-1.5 bg-yellow-600 hover:bg-yellow-700 rounded-lg text-white text-sm font-bold transition-colors">Reset
                            Rotors</button>
                    </div>
                </div>

                <!-- Painel de Luzes (Lampboard) -->
                <div id="lampboard" class="grid grid-cols-9 gap-1.5 p-3 bg-black/50 rounded-lg mb-4 justify-center">
                    <!-- As lâmpadas serão inseridas aqui pelo JavaScript -->
                </div>

                <!-- Teclado -->
                <div id="keyboard" class="grid grid-cols-9 gap-1.5 p-3 bg-black/50 rounded-lg justify-center">
                    <!-- As teclas serão inseridas aqui pelo JavaScript -->
                </div>
            </div>

            <!-- Plugboard -->
            <div class="w-full bg-[#111] p-4 rounded-xl shadow-2xl border border-gray-700">
                <h3 class="text-lg font-title text-yellow-400 mb-2 text-center">Plugboard (Steckerbrett)</h3>
                <p class="text-center text-xs text-gray-400 mb-3">Click two letters to connect a cable.</p>
                <div id="plugboard" class="grid grid-cols-9 gap-1 justify-center">
                    <!-- Os conectores do plugboard serão inseridos aqui pelo JavaScript -->
                </div>
                <div class="text-center mt-3 flex justify-center">
                    <button id="random-plugs"
                        class="px-3 py-1.5 bg-yellow-600 hover:bg-yellow-700 rounded-lg text-white text-sm font-bold transition-colors">Random
                        Plugs</button>
                </div>
                <div class="mt-4">
                    <h4 class="text-sm font-title text-yellow-400 mb-2 text-center">Decryption Setup</h4>
                    <textarea id="share-config"
                        class="w-full h-24 p-3 rounded-lg focus:outline-none focus:ring-2 focus:ring-yellow-500 resize-y text-xs"
                        placeholder="Copy and paste this setup with the recipient..."></textarea>
                    <div class="text-center mt-2">
                        <button id="copy-share-config"
                            class="px-3 py-1.5 bg-yellow-600 hover:bg-yellow-700 rounded-lg text-white text-sm font-bold transition-colors">Copy
                            Configuration</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Help Modal -->
    <div id="help-modal" class="fixed inset-0 hidden items-center justify-center bg-black/70 p-4 z-50">
        <div class="w-full max-w-2xl bg-[#111] border border-gray-700 rounded-xl shadow-2xl p-4">
            <div class="flex items-center justify-between mb-3">
                <h3 class="text-lg font-title text-yellow-400">How to use the simulator</h3>
                <button id="help-close"
                    class="px-3 py-1.5 bg-gray-600 hover:bg-gray-700 rounded-lg text-white text-sm font-bold transition-colors">Close</button>
            </div>
            <div class="text-sm text-gray-200 space-y-3">
                <p><span class="text-yellow-400 font-bold">1)</span> When the page loads (or you click <span
                        class="text-yellow-400 font-bold">Reset Enigma</span>), the plugs and rotors are randomized
                    automatically. The initial setup appears in <span class="text-yellow-400 font-bold">Decryption
                        Setup</span>.</p>
                <p><span class="text-yellow-400 font-bold">2)</span> Type using your physical keyboard or click the
                    keys. Plaintext appears in <span class="text-yellow-400 font-bold">Input</span> and
                    ciphertext in <span class="text-yellow-400 font-bold">Output</span>.</p>
                <p><span class="text-yellow-400 font-bold">3)</span> <span
                        class="text-yellow-400 font-bold">Space</span> is supported and does not move the rotors (it
                    only separates words).</p>
                <p><span class="text-yellow-400 font-bold">4)</span> Use <span
                        class="text-yellow-400 font-bold">Backspace/Delete</span> to remove the last character. If it
                    was a letter, the simulator also undoes the last rotor movement.</p>
                <p><span class="text-yellow-400 font-bold">5)</span> To send a message to someone, send the <span
                        class="text-yellow-400 font-bold">ciphertext</span> and share the <span
                        class="text-yellow-400 font-bold">Decryption Setup</span> (rotor initialization and
                    plugs) over a <span class="text-yellow-400 font-bold">separate secure channel</span> (e.g., another
                    app, a call, or end-to-end encrypted message). This follows good practice: do not send the "key"
                    together with the message itself.</p>
                <p><span class="text-yellow-400 font-bold">6)</span> The simulator ignores keyboard auto-repeat:
                    holding a key does not generate multiple letters; the key is only highlighted on the machine.</p>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // ---------------------------------------------------------------------
            // Versão do simulador
            // - IMPORTANTE: a cada alteração neste arquivo, incremente esta versão
            //   e o texto exibido no rodapé (elemento #app-version).
            // - Versão anterior informada pelo usuário: 1.06
            // ---------------------------------------------------------------------
            const APP_VERSION = '1.19';

            // Definições dos componentes da Enigma (rotores e refletor)
            const ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';

            const ROTOR_CONFIG = {
                'I': { wiring: 'EKMFLGDQVZNTOWYHXUSPAIBRCJ', notch: 'Q' },
                'II': { wiring: 'AJDKSIRUXBLHWTMCQGZNPYFVOE', notch: 'E' },
                'III': { wiring: 'BDFHJLCPRTXVZNYEIWGAKMUSQO', notch: 'V' },
            };
            const REFLECTOR_B = 'YRUHQSLDPXNGOKMIEBFZCWVJAT';

            // Estado da máquina
            let enigmaState = {
                rotors: [
                    { id: 'I', position: 0, ring: 0 },
                    { id: 'II', position: 0, ring: 0 },
                    { id: 'III', position: 0, ring: 0 }
                ],
                plugboard: {} // Mapeia letra para letra, ex: { 'A': 'B', 'B': 'A' }
            };

            const keyboardLayout = [
                'Q', 'W', 'E', 'R', 'T', 'Z', 'U', 'I', 'O',
                'A', 'S', 'D', 'F', 'G', 'H', 'J', 'K',
                'P', 'Y', 'X', 'C', 'V', 'B', 'N', 'M', 'L'
            ];

            const lampboardLayout = keyboardLayout;

            // Elementos do DOM
            const notepadEl = document.getElementById('notepad');
            const rotorsSettingsEl = document.getElementById('rotors-settings');
            const lampboardEl = document.getElementById('lampboard');
            const keyboardEl = document.getElementById('keyboard');
            const plugboardEl = document.getElementById('plugboard');
            const outputDisplayEl = document.getElementById('output-display');
            const clearOutputBtn = document.getElementById('clear-output');
            const transferBtn = document.getElementById('transfer-btn');
            const resetRotorsBtn = document.getElementById('reset-rotors');
            const randomPlugsBtn = document.getElementById('random-plugs');
            const shareConfigEl = document.getElementById('share-config');
            const copyShareConfigBtn = document.getElementById('copy-share-config');
            const importConfigEl = document.getElementById('import-config');
            const importProgressEl = document.getElementById('import-progress');
            const loadImportConfigBtn = document.getElementById('load-import-config');
            const helpBtn = document.getElementById('help-btn');
            const helpModalEl = document.getElementById('help-modal');
            const helpCloseBtn = document.getElementById('help-close');
            const appVersionEl = document.getElementById('app-version');

            // ---------------------------------------------------------------------
            // Áudio (efeitos sonoros)
            // - Arquivos esperados na mesma pasta do HTML: aperta.wav e solta.wav
            // - Pré-carrega os sons para reduzir latência no primeiro uso.
            // ---------------------------------------------------------------------
            const pressSound = new Audio('./aperta.wav');
            const releaseSound = new Audio('./solta.wav');
            pressSound.preload = 'auto';
            releaseSound.preload = 'auto';
            // Tenta aquecer o cache (alguns navegadores exigem interação do usuário para tocar).
            pressSound.load();
            releaseSound.load();

            function playSound(audioEl) {
                try {
                    // Reinicia para permitir disparos rápidos.
                    audioEl.currentTime = 0;
                    const p = audioEl.play();
                    // Ignora erros comuns de autoplay/gesture.
                    if (p && typeof p.catch === 'function') p.catch(() => { });
                } catch (_) {
                    // Silenciosamente ignora falhas.
                }
            }

            let selectedPlug = null;
            let rotorHistory = [];
            let importProgressTimer = null;
            let importProgressToken = 0;

            // Guarda a inicialização dos rotores usada no início da mensagem.
            // A cada nova mensagem (Reiniciar Enigma) este valor é refeito.
            let initialRotorPositions = null;

            // Evita repetição ao segurar uma tecla: registra quais teclas estão pressionadas.
            const pressedKeys = new Set();
            const pressedKeyLampMap = new Map();
            let activeLampKey = null;

            // Atualiza o rodapé com a versão corrente (fonte de verdade: APP_VERSION).
            if (appVersionEl) {
                appVersionEl.textContent = `Version: ${APP_VERSION}`;
            }

            // --- Funções de Inicialização da UI ---

            function createRotorControls() {
                rotorsSettingsEl.innerHTML = '';
                enigmaState.rotors.forEach((rotor, index) => {
                    const rotorContainer = document.createElement('div');
                    rotorContainer.className = 'flex flex-col items-center gap-1';

                    const rotorLabel = document.createElement('span');
                    rotorLabel.className = 'text-xs text-gray-400';
                    rotorLabel.textContent = `Rotor ${index + 1}`;

                    const rotorDisplay = document.createElement('div');
                    rotorDisplay.id = `rotor-display-${index}`;
                    rotorDisplay.className = 'rotor-display w-12 h-12 flex items-center justify-center text-3xl font-bold rounded-lg select-none';
                    rotorDisplay.textContent = ALPHABET[rotor.position];

                    const upButton = document.createElement('button');
                    upButton.innerHTML = '&#9650;';
                    upButton.className = 'px-3 text-lg hover:text-yellow-400';
                    upButton.onclick = () => stepRotorManually(index, 1);

                    const downButton = document.createElement('button');
                    downButton.innerHTML = '&#9660;';
                    downButton.className = 'px-3 text-lg hover:text-yellow-400';
                    downButton.onclick = () => stepRotorManually(index, -1);

                    rotorContainer.appendChild(rotorLabel);
                    rotorContainer.appendChild(downButton);
                    rotorContainer.appendChild(rotorDisplay);
                    rotorContainer.appendChild(upButton);
                    rotorsSettingsEl.appendChild(rotorContainer);
                });
            }

            function stepRotorManually(rotorIndex, direction) {
                let newPosition = (enigmaState.rotors[rotorIndex].position + direction + 26) % 26;
                enigmaState.rotors[rotorIndex].position = newPosition;
                updateRotorDisplay(rotorIndex);
                // Se ainda não há mensagem, mantém o snapshot inicial coerente.
                maybeSetInitialRotorPositions();
                updateShareConfig();
            }

            function resetRotorsToAAA() {
                enigmaState.rotors[0].position = 0;
                enigmaState.rotors[1].position = 0;
                enigmaState.rotors[2].position = 0;
                updateRotorDisplay(0);
                updateRotorDisplay(1);
                updateRotorDisplay(2);
                rotorHistory = [];
                // Se ainda não há mensagem, define AAA como inicialização.
                maybeSetInitialRotorPositions();
                updateShareConfig();
            }
            function randomizeRotors() {
                // Randomiza a posição dos três rotores (A-Z).
                // Observação: isso não muda o tipo de rotor (I/II/III), apenas a posição.
                enigmaState.rotors.forEach((r, idx) => {
                    r.position = Math.floor(Math.random() * 26);
                    updateRotorDisplay(idx);
                });

                // Ao randomizar, invalida o histórico de stepping.
                rotorHistory = [];

                // Atualiza snapshot inicial se não há mensagem em andamento.
                maybeSetInitialRotorPositions();
                updateShareConfig();
            }

            function maybeSetInitialRotorPositions() {
                // Define a inicialização dos rotores somente se ainda não há mensagem em andamento.
                // Isso garante que a caixa "Configuração para Decifrar" mostre a inicialização
                // usada no início da mensagem (e não as posições atuais após o stepping).
                const hasMessage = (notepadEl.value || '').length > 0 || (outputDisplayEl.textContent || '').length > 0;
                if (!hasMessage) {
                    initialRotorPositions = enigmaState.rotors.map(r => r.position);
                }
            }

            function setInitialRotorPositionsFromCurrent() {
                // Força o snapshot inicial para as posições atuais.
                initialRotorPositions = enigmaState.rotors.map(r => r.position);
            }

            function highlightKeyOnMachine(key, isDown) {
                // Mantém a tecla da máquina "pressionada" visualmente.
                const keyEl = keyboardEl.querySelector(`.enigma-key[data-key="${key}"]`);
                if (!keyEl) return;
                if (isDown) {
                    keyEl.classList.add('bg-yellow-500');
                } else {
                    keyEl.classList.remove('bg-yellow-500');
                }
            }

            async function copyShareConfigToClipboard() {
                // Copia o conteúdo de "Configuração para Decifrar" para a área de transferência.
                if (!shareConfigEl) return;
                const text = shareConfigEl.value || '';
                if (!text) return;

                try {
                    await navigator.clipboard.writeText(text);
                } catch (err) {
                    // Fallback para navegadores que não permitem clipboard via API.
                    shareConfigEl.focus();
                    shareConfigEl.select();
                    document.execCommand('copy');
                }
            }

            function parseImportedConfig(text) {
                const normalized = (text || '').toUpperCase();
                const rotorMatch = normalized.match(/ROTOR\s+INITIALIZATION:\s*([A-Z])\s+([A-Z])\s+([A-Z])/);
                if (!rotorMatch) return null;

                const rotors = rotorMatch.slice(1, 4).map(letter => ALPHABET.indexOf(letter));
                if (rotors.some(idx => idx < 0)) return null;

                const plugMatch = normalized.match(/PLUGBOARD\s+SETUP:\s*([A-Z\s]*)/);
                const pairsText = plugMatch ? plugMatch[1].trim() : '';
                const pairs = pairsText ? pairsText.split(/\s+/).filter(pair => pair.length === 2) : [];

                return { rotors, pairs };
            }

            function applyImportedConfig(config) {
                if (!config) return;

                enigmaState.rotors[0].position = config.rotors[0];
                enigmaState.rotors[1].position = config.rotors[1];
                enigmaState.rotors[2].position = config.rotors[2];
                updateRotorDisplay(0);
                updateRotorDisplay(1);
                updateRotorDisplay(2);

                const newPlugboard = {};
                const used = new Set();
                config.pairs.forEach(pair => {
                    const a = pair[0];
                    const b = pair[1];
                    if (!a || !b || a === b) return;
                    if (used.has(a) || used.has(b)) return;
                    if (!ALPHABET.includes(a) || !ALPHABET.includes(b)) return;
                    newPlugboard[a] = b;
                    newPlugboard[b] = a;
                    used.add(a);
                    used.add(b);
                });

                enigmaState.plugboard = newPlugboard;
                rotorHistory = [];
                setInitialRotorPositionsFromCurrent();
                updatePlugboardUI();
                updateShareConfig();
            }

            function startImportProgress(onComplete) {
                if (!importProgressEl) return;
                const token = ++importProgressToken;
                if (importProgressTimer) {
                    clearInterval(importProgressTimer);
                }
                importProgressEl.style.width = '0%';
                let progress = 0;
                const durationMs = 1200;
                const intervalMs = 30;
                const step = 100 / (durationMs / intervalMs);
                importProgressTimer = setInterval(() => {
                    progress = Math.min(100, progress + step);
                    importProgressEl.style.width = `${progress}%`;
                    if (progress >= 100) {
                        clearInterval(importProgressTimer);
                        importProgressTimer = null;
                        if (token === importProgressToken && typeof onComplete === 'function') {
                            onComplete();
                        }
                        setTimeout(() => {
                            if (token === importProgressToken) {
                                importProgressEl.style.width = '0%';
                            }
                        }, 400);
                    }
                }, intervalMs);
            }

            function openHelpModal() {
                // Abre o modal (display flex) mantendo o resto do layout intacto.
                if (!helpModalEl) return;
                helpModalEl.classList.remove('hidden');
                helpModalEl.classList.add('flex');
            }

            function closeHelpModal() {
                // Fecha o modal.
                if (!helpModalEl) return;
                helpModalEl.classList.add('hidden');
                helpModalEl.classList.remove('flex');
            }

            function createKeyboardAndLamps() {
                const createKeyElement = (char, type) => {
                    const el = document.createElement('div');
                    el.textContent = char;
                    el.dataset.key = char;

                    if (type === 'key') {
                        el.className = 'enigma-key w-9 h-9 md:w-10 md:h-10 flex items-center justify-center bg-gray-700 rounded-full cursor-pointer select-none text-lg font-bold';
                        // Adiciona efeitos sonoros de mouse press/release e destaque visual
                        el.addEventListener('mousedown', () => {
                            highlightKeyOnMachine(char, true);
                            playSound(pressSound);
                        });
                        el.addEventListener('mouseup', () => {
                            highlightKeyOnMachine(char, false);
                            playSound(releaseSound);
                        });
                        el.addEventListener('mouseleave', () => {
                            highlightKeyOnMachine(char, false);
                        });
                        el.addEventListener('click', () => handleKeyPress(char));
                    } else { // lamp
                        el.className = 'lamp w-9 h-9 md:w-10 md:h-10 flex items-center justify-center bg-gray-800/50 text-yellow-600 rounded-full text-lg font-bold border-2 border-gray-600';
                    }
                    return el;
                };

                keyboardLayout.forEach(char => keyboardEl.appendChild(createKeyElement(char, 'key')));
                lampboardLayout.forEach(char => lampboardEl.appendChild(createKeyElement(char, 'lamp')));
            }

            function createPlugboard() {
                plugboardEl.innerHTML = '';
                ALPHABET.split('').forEach(char => {
                    const socket = document.createElement('div');
                    socket.textContent = char;
                    socket.dataset.char = char;
                    socket.className = 'plug-socket w-7 h-7 flex items-center justify-center bg-gray-700 rounded-full cursor-pointer select-none font-bold text-xs';
                    socket.addEventListener('click', () => handlePlugClick(char));
                    plugboardEl.appendChild(socket);
                });
            }

            // --- Funções de Atualização da UI ---

            function updateRotorDisplay(rotorIndex) {
                const display = document.getElementById(`rotor-display-${rotorIndex}`);
                if (display) {
                    display.textContent = ALPHABET[enigmaState.rotors[rotorIndex].position];
                }
            }

            function clearAllLamps() {
                const lamps = lampboardEl.querySelectorAll('.lamp');
                lamps.forEach(lamp => lamp.classList.remove('lit'));
                activeLampKey = null;
            }

            function holdLamp(char) {
                clearAllLamps();
                if (!char) return;
                const lampToLight = lampboardEl.querySelector(`.lamp[data-key="${char}"]`);
                if (lampToLight) {
                    lampToLight.classList.add('lit');
                    activeLampKey = char;
                }
            }

            function flashLamp(char) {
                clearAllLamps();
                if (!char) return;
                const lampToLight = lampboardEl.querySelector(`.lamp[data-key="${char}"]`);
                if (lampToLight) {
                    lampToLight.classList.add('lit');
                    setTimeout(() => {
                        lampToLight.classList.remove('lit');
                    }, 500);
                }
            }

            function updatePlugboardUI() {
                const sockets = plugboardEl.querySelectorAll('.plug-socket');
                // Primeiro, reseta todos os estilos visuais.
                sockets.forEach(socket => {
                    socket.classList.remove('selected');
                    socket.style.backgroundColor = '';
                    socket.style.color = '';
                });

                const colors = ['#f87171', '#fb923c', '#fbbf24', '#a3e635', '#4ade80', '#34d399', '#22d3ee', '#60a5fa', '#a78bfa', '#f472b6'];
                const usedColors = {};
                let colorIndex = 0;

                // Colore os pares já conectados
                for (const charA in enigmaState.plugboard) {
                    const charB = enigmaState.plugboard[charA];
                    if (!usedColors[charA] && !usedColors[charB]) {
                        const color = colors[colorIndex % colors.length];
                        const socketA = plugboardEl.querySelector(`.plug-socket[data-char="${charA}"]`);
                        const socketB = plugboardEl.querySelector(`.plug-socket[data-char="${charB}"]`);
                        if (socketA) {
                            socketA.style.backgroundColor = color;
                            socketA.style.color = '#1a1a1a';
                        }
                        if (socketB) {
                            socketB.style.backgroundColor = color;
                            socketB.style.color = '#1a1a1a';
                        }
                        usedColors[charA] = true;
                        usedColors[charB] = true;
                        colorIndex++;
                    }
                }

                // Se houver um plugue selecionado aguardando par, destaque-o.
                if (selectedPlug) {
                    const selectedSocket = plugboardEl.querySelector(`.plug-socket[data-char="${selectedPlug}"]`);
                    if (selectedSocket) {
                        selectedSocket.classList.add('selected');
                    }
                }
            }

            // --- Lógica do Plugboard ---

            function handlePlugClick(char) {
                // Se a letra já está conectada, remove a conexão.
                if (enigmaState.plugboard[char]) {
                    const otherChar = enigmaState.plugboard[char];
                    delete enigmaState.plugboard[char];
                    delete enigmaState.plugboard[otherChar];
                    selectedPlug = null;
                }
                // Se nenhum plugue está selecionado, seleciona o atual.
                else if (!selectedPlug) {
                    selectedPlug = char;
                }
                // Se um plugue já está selecionado, cria a conexão.
                else if (selectedPlug !== char) {
                    enigmaState.plugboard[selectedPlug] = char;
                    enigmaState.plugboard[char] = selectedPlug;
                    selectedPlug = null;
                }
                // Se o mesmo plugue for clicado duas vezes, deseleciona.
                else {
                    selectedPlug = null;
                }
                // Atualiza a UI para refletir o novo estado.
                updatePlugboardUI();
                updateShareConfig();
            }

            function randomizePlugboard() {
                // Reset existing plugboard
                enigmaState.plugboard = {};
                selectedPlug = null;

                // Shuffle alphabet and create up to 13 random pairs (26 letters, all paired)
                const letters = ALPHABET.split('');
                for (let i = letters.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [letters[i], letters[j]] = [letters[j], letters[i]];
                }

                const pairsCount = 13; // connect all letters (13 pairs)
                const maxLetters = Math.min(pairsCount * 2, letters.length);

                for (let i = 0; i < maxLetters; i += 2) {
                    const a = letters[i];
                    const b = letters[i + 1];
                    if (!a || !b) break;
                    enigmaState.plugboard[a] = b;
                    enigmaState.plugboard[b] = a;
                }

                // Se ainda não há mensagem, snapshot inicial pode ser atualizado.
                maybeSetInitialRotorPositions();

                updatePlugboardUI();
                updateShareConfig();
            }

            // --- Lógica Principal da Enigma ---

            function stepRotors() {
                const rotors = enigmaState.rotors;
                const rotorIII = rotors[2];
                const rotorII = rotors[1];
                const rotorI = rotors[0];
                // Salva as posições atuais antes do stepping para permitir undo (Backspace/Delete).
                rotorHistory.push([rotorI.position, rotorII.position, rotorIII.position]);

                const rotorIIAtNotch = ALPHABET[rotorII.position] === ROTOR_CONFIG[rotorII.id].notch;
                if (rotorIIAtNotch) {
                    rotorII.position = (rotorII.position + 1) % 26;
                    rotorI.position = (rotorI.position + 1) % 26;
                }

                const rotorIIIAtNotch = ALPHABET[rotorIII.position] === ROTOR_CONFIG[rotorIII.id].notch;
                if (rotorIIIAtNotch) {
                    rotorII.position = (rotorII.position + 1) % 26;
                }

                rotorIII.position = (rotorIII.position + 1) % 26;

                updateRotorDisplay(0);
                updateRotorDisplay(1);
                updateRotorDisplay(2);
            }

            function passThrough(charIndex, component, reverse = false) {
                if (typeof component === 'string') {
                    const entryChar = ALPHABET[charIndex];
                    const exitChar = component[ALPHABET.indexOf(entryChar)];
                    return ALPHABET.indexOf(exitChar);
                }

                const rotor = component;
                const pos = rotor.position;
                const ring = rotor.ring;

                const entryIndex = (charIndex + pos - ring + 26) % 26;

                let exitIndex;
                if (!reverse) {
                    const exitChar = rotor.wiring[entryIndex];
                    exitIndex = (ALPHABET.indexOf(exitChar) - pos + ring + 26) % 26;
                } else {
                    const entryChar = ALPHABET[entryIndex];
                    const exitChar = ALPHABET[rotor.wiring.indexOf(entryChar)];
                    exitIndex = (ALPHABET.indexOf(exitChar) - pos + ring + 26) % 26;
                }
                return exitIndex;
            }

            function encrypt(char) {
                stepRotors();

                let processedChar = enigmaState.plugboard[char] || char;
                let charIndex = ALPHABET.indexOf(processedChar);

                const rotorIII = { ...ROTOR_CONFIG[enigmaState.rotors[2].id], ...enigmaState.rotors[2] };
                const rotorII = { ...ROTOR_CONFIG[enigmaState.rotors[1].id], ...enigmaState.rotors[1] };
                const rotorI = { ...ROTOR_CONFIG[enigmaState.rotors[0].id], ...enigmaState.rotors[0] };

                charIndex = passThrough(charIndex, rotorIII);
                charIndex = passThrough(charIndex, rotorII);
                charIndex = passThrough(charIndex, rotorI);

                charIndex = passThrough(charIndex, REFLECTOR_B);

                charIndex = passThrough(charIndex, rotorI, true);
                charIndex = passThrough(charIndex, rotorII, true);
                charIndex = passThrough(charIndex, rotorIII, true);

                processedChar = ALPHABET[charIndex];

                processedChar = enigmaState.plugboard[processedChar] || processedChar;

                return processedChar;
            }

            // --- Manipuladores de Eventos ---

            function handleKeyPress(char, options = {}) {
                // Aceita letras A-Z e também espaço.
                // - Letras: cifram, movem rotores e acendem a lâmpada.
                // - Espaço: apenas separa palavras (não move rotores e não cifra).
                const isSpace = char === ' ';
                const upperChar = isSpace ? ' ' : String(char || '').toUpperCase();

                if (isSpace) {
                    // Espaço não altera estado de rotores; só espelha nos dois campos.
                    notepadEl.value = (notepadEl.value + ' ').toUpperCase();
                    outputDisplayEl.textContent += ' ';
                    notepadEl.scrollTop = notepadEl.scrollHeight;
                    outputDisplayEl.scrollTop = outputDisplayEl.scrollHeight;
                    updateShareConfig();
                    return;
                }

                if (ALPHABET.includes(upperChar)) {
                    // Captura a inicialização apenas no começo da mensagem.
                    maybeSetInitialRotorPositions();

                    // Sempre mantém o texto em claro em uppercase.
                    notepadEl.value = (notepadEl.value + upperChar).toUpperCase();
                    notepadEl.scrollTop = notepadEl.scrollHeight;

                    const encryptedChar = encrypt(upperChar);
                    if (options.holdLamp) {
                        holdLamp(encryptedChar);
                    } else {
                        flashLamp(encryptedChar);
                    }
                    outputDisplayEl.textContent += encryptedChar;
                    outputDisplayEl.scrollTop = outputDisplayEl.scrollHeight;
                    updateShareConfig();
                    return encryptedChar;
                }
                return null;
            }

            function undoLastKeypress() {
                // Detecta o último caractere do texto cifrado para decidir se deve desfazer rotores.
                const lastCipherChar = outputDisplayEl.textContent.slice(-1);

                // Remove o último caractere do texto em claro.
                if (notepadEl.value.length > 0) {
                    notepadEl.value = notepadEl.value.slice(0, -1);
                }

                // Remove o último caractere do texto cifrado.
                if (outputDisplayEl.textContent.length > 0) {
                    outputDisplayEl.textContent = outputDisplayEl.textContent.slice(0, -1);
                }

                // Se o último caractere era espaço, não desfaz stepping de rotores.
                if (lastCipherChar === ' ') {
                    clearAllLamps();
                    updateShareConfig();
                    return;
                }

                // Se era letra, desfaz o stepping usando o histórico.
                if (rotorHistory.length > 0) {
                    const last = rotorHistory.pop();
                    enigmaState.rotors[0].position = last[0];
                    enigmaState.rotors[1].position = last[1];
                    enigmaState.rotors[2].position = last[2];
                    updateRotorDisplay(0);
                    updateRotorDisplay(1);
                    updateRotorDisplay(2);
                }

                // Apaga lâmpadas.
                clearAllLamps();
                updateShareConfig();
            }

            document.addEventListener('keydown', (e) => {
                // Permite atalhos (Ctrl/Cmd/Alt) sem interferência.
                if (e.ctrlKey || e.metaKey || e.altKey) return;

                // Fecha modal com ESC.
                if (e.key === 'Escape') {
                    closeHelpModal();
                    return;
                }

                // Backspace/Delete: desfaz última entrada.
                if (e.key === 'Backspace' || e.key === 'Delete') {
                    e.preventDefault();
                    undoLastKeypress();
                    return;
                }

                // Espaço.
                if (e.key === ' ') {
                    const spaceKey = ' ';
                    // Evita repetição ao segurar espaço.
                    if (pressedKeys.has(spaceKey)) {
                        return;
                    }
                    e.preventDefault();
                    pressedKeys.add(spaceKey);
                    playSound(pressSound);
                    handleKeyPress(' ');
                    return;
                }

                const key = (e.key || '').toUpperCase();

                // Evita repetição automática: se estiver repetindo, apenas mantém destaque.
                if (e.repeat) {
                    if (key.length === 1 && ALPHABET.includes(key)) {
                        highlightKeyOnMachine(key, true);
                    }
                    // Não toca som nem processa handleKeyPress em repetição.
                    return;
                }

                // Se a tecla já está pressionada, não processa novamente.
                if (pressedKeys.has(key)) {
                    return;
                }

                // Aceita A-Z do teclado físico.
                if (key.length === 1 && ALPHABET.includes(key)) {
                    // Se já está pressionada, não toca som nem adiciona caracteres.
                    if (pressedKeys.has(key)) {
                        highlightKeyOnMachine(key, true);
                        return;
                    }
                    e.preventDefault();
                    pressedKeys.add(key);
                    highlightKeyOnMachine(key, true);
                    playSound(pressSound);
                    const encryptedChar = handleKeyPress(key, { holdLamp: true });
                    if (encryptedChar) {
                        pressedKeyLampMap.set(key, encryptedChar);
                    }
                }
            });

            document.addEventListener('keyup', (e) => {
                // Suporte ao som de solta para ESPAÇO (barra de espaço)
                if (e.key === ' ') {
                    const spaceKey = ' ';
                    if (pressedKeys.has(spaceKey)) {
                        pressedKeys.delete(spaceKey);
                        playSound(releaseSound);
                    }
                    return;
                }
                const key = (e.key || '').toUpperCase();
                if (key.length === 1 && ALPHABET.includes(key)) {
                    if (pressedKeys.has(key)) {
                        pressedKeys.delete(key);
                        highlightKeyOnMachine(key, false);
                        playSound(releaseSound);
                        const lampChar = pressedKeyLampMap.get(key);
                        if (lampChar && lampChar === activeLampKey) {
                            clearAllLamps();
                        }
                        pressedKeyLampMap.delete(key);
                    } else {
                        // Garante que a tecla não fique presa visualmente.
                        highlightKeyOnMachine(key, false);
                    }
                }
            });

            if (randomPlugsBtn) {
                randomPlugsBtn.addEventListener('click', () => {
                    randomizePlugboard();
                });
            }

            if (resetRotorsBtn) {
                resetRotorsBtn.addEventListener('click', () => {
                    resetRotorsToAAA();
                });
            }

            clearOutputBtn.addEventListener('click', () => {
                // Reinicia a mensagem: zera campos e cria nova configuração (rotores + plugs).
                notepadEl.value = '';
                outputDisplayEl.textContent = '';

                // Reseta e randomiza.
                resetRotorsToAAA();
                randomizeRotors();
                randomizePlugboard();

                // Snapshot inicial para compartilhar.
                setInitialRotorPositionsFromCurrent();
                updateShareConfig();

                // Apaga lâmpadas.
                clearAllLamps();
            });
            function updateShareConfig() {
                if (!shareConfigEl) return;

                const base = (initialRotorPositions && initialRotorPositions.length === 3)
                    ? initialRotorPositions
                    : enigmaState.rotors.map(r => r.position);
                const rotorLetters = base.map(pos => ALPHABET[pos]).join(' ');

                // Build plug pairs like "AB CD EF ..." (unique pairs only)
                const seen = new Set();
                const pairs = [];
                for (const a in enigmaState.plugboard) {
                    const b = enigmaState.plugboard[a];
                    const key = [a, b].sort().join('');
                    if (!seen.has(key)) {
                        seen.add(key);
                        pairs.push(`${a}${b}`);
                    }
                }
                pairs.sort();

                shareConfigEl.value = `Rotor initialization: ${rotorLetters}\nPlugboard setup: ${pairs.join(' ')}`;
            }

            // Event listener para o botão de transferência
            transferBtn.addEventListener('click', () => {
                const ciphertext = outputDisplayEl.textContent;
                if (ciphertext.trim() !== '') {
                    notepadEl.value = ciphertext;
                    outputDisplayEl.textContent = '';
                }
            });

            notepadEl.addEventListener('input', () => {
                // Mantém uppercase inclusive para conteúdo colado (paste).
                const start = notepadEl.selectionStart;
                const end = notepadEl.selectionEnd;
                notepadEl.value = notepadEl.value.toUpperCase();
                // Keep cursor position stable
                notepadEl.setSelectionRange(start, end);
            });

            // Ensure the simulator captures keyboard typing when the user interacts with it.
            const simulatorFocusTargets = [rotorsSettingsEl, lampboardEl, keyboardEl, plugboardEl, outputDisplayEl];
            simulatorFocusTargets.forEach((el) => {
                if (!el) return;
                el.addEventListener('click', () => {
                    // Remove focus from the notepad so keystrokes go to the simulator.
                    if (document.activeElement === notepadEl) {
                        notepadEl.blur();
                    }
                });
            });

            // --- Inicialização ---
            function init() {
                // Monta UI.
                createRotorControls();
                createKeyboardAndLamps();
                createPlugboard();

                // Ao abrir a página: randomiza rotores e plugs automaticamente.
                randomizeRotors();
                randomizePlugboard();

                // Define snapshot inicial para compartilhar.
                setInitialRotorPositionsFromCurrent();

                updatePlugboardUI();
                updateShareConfig();
            }

            // Botão para copiar configuração de compartilhamento
            if (copyShareConfigBtn) {
                copyShareConfigBtn.addEventListener('click', () => {
                    copyShareConfigToClipboard();
                });
            }

            if (helpBtn) {
                helpBtn.addEventListener('click', () => {
                    openHelpModal();
                });
            }

            if (helpCloseBtn) {
                helpCloseBtn.addEventListener('click', () => {
                    closeHelpModal();
                });
            }

            if (helpModalEl) {
                // Clique no fundo fecha o modal.
                helpModalEl.addEventListener('click', (ev) => {
                    if (ev.target === helpModalEl) {
                        closeHelpModal();
                    }
                });
            }

            if (importConfigEl) {
                const handleImportInput = () => {
                    const parsed = parseImportedConfig(importConfigEl.value || '');
                    if (!parsed) return;
                    startImportProgress(() => {
                        applyImportedConfig(parsed);
                    });
                };
                importConfigEl.addEventListener('paste', () => {
                    setTimeout(handleImportInput, 0);
                });
                importConfigEl.addEventListener('input', handleImportInput);
            }

            if (loadImportConfigBtn && importConfigEl) {
                loadImportConfigBtn.addEventListener('click', () => {
                    const parsed = parseImportedConfig(importConfigEl.value || '');
                    if (!parsed) return;
                    startImportProgress(() => {
                        applyImportedConfig(parsed);
                    });
                });
            }

            init();
        });
    </script>

    <footer class="mt-6 text-xs text-gray-500 text-center">
        <p>Copyright: Galeno Garbe - All rights reserved 2025.</p>
    </footer>
</body>

</html>